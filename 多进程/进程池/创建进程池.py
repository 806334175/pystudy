#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2019/10/8 上午9:58
# @Author  : Ryu
# @Site    : 
# @File    : 创建进程池.py
# @Software: PyCharm

# 在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。多进程是实现并发的手段之一，需要注意的问题是：
#
# 很明显需要并发执行的任务通常要远大于核数
# 一个操作系统不可能无限开启进程，通常有几个核就开几个进程
# 进程开启过多，效率反而会下降（开启进程是需要占用系统资源的，而且开启多余核数目的进程也无法做到并行）
# 例如当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个。。。手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。
#
# 我们就可以通过维护一个进程池来控制进程数目，比如httpd的进程模式，规定最小进程数和最大进程数...
# ps：对于远程过程调用的高级应用程序而言，应该使用进程池，Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。


# 创建进程池的类：如果指定numprocess为3，则进程池会从无到有创建三个进程，然后自始至终使用这三个进程去执行所有任务，不会开启其他进程
# 1 Pool([numprocess  [,initializer [, initargs]]]):创建进程池

# 参数介绍：
# 1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值
# 2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None
# 3 initargs：是要传给initializer的参数组

# 方法介绍：
#
# 主要方法：

# p.apply(func[, args[, kwargs]]):在一个池工作进程中执行func(*args,**kwargs), 然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()
# p.apply_async(func[, args[, kwargs]]):在一个池工作进程中执行func(*args,**kwargs), 然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。
# p.close(): 关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成
# P.jion(): 等待所有工作进程退出。此方法只能在close（）或teminate()之后调用

# 方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法
#     obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。
#     obj.ready():如果调用完成，返回True
#     obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常
#     obj.wait([timeout]):等待结果变为可用。
#     obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数